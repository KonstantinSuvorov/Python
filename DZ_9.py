# Задача 1.
# Напишите функцию to_dict(lst), которая принимает 
# аргумент в виде списка и возвращает словарь, 
# в котором каждый элемент списка является и ключом и значением. 
# Предполагается, что элементы списка будут соответствовать 
# правилам задания ключей в словарях.

# def to_dict(list):
#     return {element: element for element in list}
# print(to_dict([0, 2, 4, 6]))
# print(to_dict([-5, 2.87, (2, 17), 'красный']))



# Задача 2.
# Иван решил создать самый большой словарь в мире. 
# Для этого он придумал функцию biggest_dict(**kwargs), 
# которая принимает неограниченное количество параметров 
# «ключ: значение» и обновляет созданный им словарь my_dict, 
# состоящий всего из одного элемента «first_one» со значением 
# «we can do it». 
# Воссоздайте эту функцию.

# my_dict = {'first_one': 'we can do it'}
# def biggest_dict(**kwargs):
#     my_dict.update(**kwargs)
# biggest_dict(k1=11, k2=22, k3=33, k4=44)
# biggest_dict(name='Анна', age=29, weight=61, eyes_color='голубые')
# print(my_dict)


# Задача 3.
# Дана строка в виде случайной последовательности чисел от 0 до 9. 
# Требуется создать словарь, который в качестве ключей будет принимать данные числа 
# (т. е. ключи будут типом int), а в качестве значений – количество этих чисел 
# в имеющейся последовательности. 
# Для построения словаря создайте функцию count_it(sequence), принимающую строку из цифр. 
# Функция должна возвратить словарь из 3-х самых часто встречаемых чисел.

# def count_it(sequence):
#     # Генерируем словарь, ключ - уникальный элемент строки, значение - его частота. 
#     # Частота вычисляется методом count()). 	
#     num_frequency = {int(item): sequence.count(item) for item in sequence}
#     # Сортируем словарь в порядке возрастания по значениям. 
#     # Методом items() формируем пары "(ключ, значение)" 
#     # в виде кортежей по всем элементам словаря. 
#     sorted_num_frequency = sorted(num_frequency.items(), key = lambda element: element[1])
#     # Возвращаем последние 3 элемента списка - кортежи с наибольшими значениями 
#     # второй компоненты, которые преобразовываем в словарь.
#     return dict(sorted_num_frequency[-3:])
# # Тесты
# print(count_it('1111112222'))
# print(count_it('12345678901234567890123123123123123123'))
# print(count_it('00557788990055778899213'))


# Вариант 2
# from collections import Counter
# def count_it(sequence):
#     return dict(Counter([int(num) for num in sequence]).most_common(3))
# # Тесты
# print(count_it('1111112222'))
# print(count_it('12345678901234567890123123123123123123'))
# print(count_it('00557788990055778899213'))



# Задача 4.* (вместо задачи 3) Написать функцию thesaurus_adv(), 
# принимающую в качестве аргументов строки в формате «Имя Фамилия» 
# и возвращающую словарь, в котором ключи — первые буквы фамилий, 
# а значения — словари, реализованные по схеме предыдущего задания 
# и содержащие записи, в которых фамилия начинается с соответствующей буквы. 
# Например: 
#>>> thesaurus_adv("Иван Сергеев", "Инна Серова", "Петр Алексеев", "Илья Иванов", "Анна Савельева")
#{ "А": { "П": ["Петр Алексеев"] }, "И": { "И": ["Илья Иванов"] }, 
# "С": { "И": ["Иван Сергеев", "Инна Серова"], "А": ["Анна Савельева"] } }

def thesaurus_adv(*args):
    out_dict = {}
    for elem in args:
        name, second_name = elem.split()
        if not out_dict.get(second_name[0]):
            out_dict[second_name[0]] = { name[0] : [elem] }
        elif not out_dict[second_name[0]].get(name[0]):
            (out_dict[second_name[0]])[name[0]] = [elem]
        else:
            (out_dict[second_name[0]])[name[0]].append(elem)
    return out_dict
print(thesaurus_adv("Иван Сергеев", "Инна Серова", "Петр Алексеев", "Илья Иванов", "Анна Савельева"))
